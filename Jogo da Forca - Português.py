# -*- coding: utf-8 -*-
"""Jogo da Forca.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XRoGqbH9LtXBFCKaA9RHQ3SBZ9OZb5QC
"""

import random

lista_verbos = ['correr', 'jogar', 'ajudar', 'competir', 'completar', 'ler', 'aprender', 'ensinar', 'escalar', 'superar',
                'escolher', 'fugir', 'lutar', 'combater', 'pular', 'herdar', 'poluir', 'esconder', 'molhar', 'secar',
                'roubar', 'furtar', 'plagiar', 'copiar', 'empurrar', 'ameaçar', 'encurralar', 'mostrar', 'rugir', 'mandar']
lista_substantivos = ['objeto', 'mesa', 'cadeira', 'montanha', 'cidade', 'terremoto', 'continente', 'rio', 'jogador', 'professor',
                      'coisa', 'computador', 'monitor', 'teclado', 'celular', 'relogio', 'calendario', 'ideia', 'tecla', 'remedio',
                      'caixa', 'bau', 'chao', 'rolha', 'vinho', 'bebida', 'vicio', 'erro', 'rodovia', 'rodizio']
lista_adjetivos = ['bonito', 'bobo', 'chato', 'velho', 'novo', 'legal', 'divertido', 'molhado', 'seco', 'irritante',
                   'estupido', 'imbecil', 'doido', 'maluco', 'viciado', 'confuso', 'tonto', 'louco', 'bravo', 'cansado',
                   'rispido', 'rude', 'grosso', 'gentil', 'alegre', 'educado', 'feliz', 'encharcado', 'suado', 'exausto']
lista_letras_encontradas = []
lista_letras_erradas = []
lista_palavra_escondida = []
num_max_erros_letras = 6
opcao1 = '1'
opcao2 = '2'
resultado_chute = None
palavra_completada = False

# JUNTA AS LISTAS DE VERBOS, SUBSTANTIVOS E ADJETIVOS E SORTEIA UMA PALAVRA
def sortear_palavra(a, b, c):
  nova_lista = a + b + c
  random.shuffle(nova_lista)
  palavra_sorteada = random.choice(nova_lista)

  return palavra_sorteada.upper()

# VERIFICA A QUANTIDADE DE CARACTERES AO ESCOLHER A OPÇÃO DE DIGITAR UMA LETRA
def verificar_quantidade_caracteres(d):
  limite_caracteres = 1

  if(len(d) > 1):
    status = True
  else:
    status = False

  return status

# VERIFICA SE O USUÁRIO DIGITOU SOMENTE LETRAS AO ESCOLHER A OPÇÃO DE DIGITAR UMA LETRA
def verificar_somente_letras(e):
  range_ord_min = 65
  range_ord_max = 90
  in_range = None

  if(ord(e) in range(range_ord_min, range_ord_max + 1)):
    in_range = True
  else:
    in_range = False

  return in_range

# VERIFICA SE A LETRA DIGITADA JÁ FOI UTILIZADA PELO USUÁRIO, INDEPENDENTE DE ESTAR CERTA OU ERRADA,
# AO ESCOLHER A OPÇÃO DE DIGITAR UMA LETRA
def verificar_letra_usada(f, g, h):
  usada_encontrada = usada_errada = None

  if((f in g) and (f in h)):
    usada_encontrada = True
    usada_errada = True
  elif((f in g) and (f not in h)):
    usada_encontrada = True
    usada_errada = False
  elif((f not in g) and (f in h)):
    usada_encontrada = False
    usada_errada = True
  else:
    usada_encontrada = False
    usada_errada = False

  return usada_encontrada, usada_errada

# VERIFICA SE A LETRA DIGITADA PELO USUÁRIO ESTÁ OU NÃO NA PALAVRA SORTEADA
def verificar_letra_palavra_sorteada(i, j):
  encontrada = None

  if(j in i):
    encontrada = True
  else:
    encontrada = False

  return encontrada

# VERIFICA EM QUAL POSIÇÃO DA PALAVRA ESTÁ A LETRA DIGITADA PELO USUÁRIO
def verificar_letra_posicao(k, l, m):

  for letras_palavra_sorteada in range(len(k)):
    for letra_user in l:
      if(k[letras_palavra_sorteada] == letra_user):
        m[letras_palavra_sorteada] = letra_user
      else:
        continue

  return m

# CONSTRÓI A FORCA, BASEANDO-SE NO NÚMERO DE ERROS QUE O USUÁRIO COMETEU
def construir_forca(n):
  parte_forca1 = parte_forca2 = parte_forca3 = ''

  if(n <= 5):
    parte_forca1 = '|         (_)'
  else:
    parte_forca1 = '|'
  if(n == 4):
    parte_forca2 = '|          |\n|          |'
  elif(n == 3):
    parte_forca2 = '|         /|\n|        / |'
  elif(n <= 2):
    parte_forca2 = '|         /|\\\n|        / | \\'
  else:
    parte_forca2 = '|\n|'
  if(n == 1):
    parte_forca3 = '|         /\n|        /'
  elif(n == 0):
    parte_forca3 = '|         / \\\n|        /   \\'
  else:
    parte_forca3 = '|'

  return parte_forca1, parte_forca2, parte_forca3

if __name__ == '__main__':
  print('Bem-vindo usuário!')
  print('Este programa é um Jogo da Forca!')
  print(f'Caso você queira tentar adivinhar somente pelas letras, você pode errar até no máximo {num_max_erros_letras} vezes!')
  print('Caso você queira tentar adivinhar a palavra certa, você só tem UMA tentativa!')

  nova_palavra = sortear_palavra(lista_verbos, lista_substantivos, lista_adjetivos)

  # CRIA UMA NOVA LISTA COM A MESMA QUANTIDADE DE CARACETERES QUE A PALAVRA SORTEADA,
  # SUBISTITUINDO CADA LETRA POR "_"
  for letras_palavra in nova_palavra:
        letras_palavra = '_'
        lista_palavra_escondida.append(letras_palavra)

  while(True):
    forca1, forca2, forca3 = construir_forca(num_max_erros_letras)

    print('____________')
    print('|          |')
    print(forca1)
    print(forca2)
    print(forca3)

    # IMPRIME NA TELA AS POSIÇÕES DA CADA LETRA DA PALAVRA COM "_" E,
    # CASO O USUÁRIO TENHA ENCONTRADO UMA LETRA, ESTÁ IRÁ SUBSTITUIR O "_"
    lista_posicoes = verificar_letra_posicao(nova_palavra, lista_letras_encontradas, lista_palavra_escondida)
    print(' '.join(lista_posicoes))

    if(len(lista_letras_erradas) > 0):
      print('Letras utilizadas:', end = ' ')
      print(' '.join(lista_letras_erradas))

    # ENQUANTO O USUÁRIO POSSUÍ TENTATIVAS, O PROGRAMA IRÁ COMPARAR SE
    # TODAS AS LETRAS QUE O USUÁRIO ACERTOU COMPLETAM A PALAVRA.
    # CASO ISSO OCORRA, O LAÇO WHILE PARA AQUI
    if(num_max_erros_letras > 0):
      if(''.join(lista_posicoes) == nova_palavra):
        palavra_completada = True
        break

      print('-' * 30)
      print(f'Erros restantes: {num_max_erros_letras}')
      print('Você deseja:')
      print(f'{opcao1} - Escolher uma letra\n{opcao2} - Tentar acertar a palavra')
      print('Por favor, escolha uma dessas opções!')
      escolha_user = input()
      print('-' * 30)

      if(escolha_user == opcao1):
        while(True):
          print('Qual letra você deseja ver se está na palavra?')
          letra_user = input()
          print('-' * 30)

          letra_user = letra_user.upper()
          acima_limite_caractere = verificar_quantidade_caracteres(letra_user)

          if(len(letra_user) == 0):
            print('Erro! Você não digitou nada!')
          else:
            if(acima_limite_caractere == True):
              print('Erro! Você só pode digitar uma letra por vez!')
            else:
              somente_letra = verificar_somente_letras(letra_user)

              if(somente_letra == False):
                print('Erro! Você não digitou uma letra!')
              else:
                letra_usada_encontrada, letra_usada_errada = verificar_letra_usada(letra_user, lista_letras_encontradas, lista_letras_erradas)

                if((letra_usada_encontrada == True) or (letra_usada_errada == True)):
                  print('Erro! Você já usou esta letra!')
                else:
                  letra_encontrada = verificar_letra_palavra_sorteada(nova_palavra, letra_user)

                  if(letra_encontrada == True):
                    lista_letras_encontradas.append(letra_user)
                  else:
                    lista_letras_erradas.append(letra_user)
                    num_max_erros_letras -= 1
                  break
          print('Por favor, tente novamente!')
          print('-' * 30)
      elif(escolha_user == opcao2):
        while(True):
          print('Qual a palavra certa?')
          chute_user = input()

          if(len(chute_user) == 0):
            print('Erro! Você não digitou nada!')
            print('Por favor, tente novamente!')
            print('-' * 30)
          else:
            if(chute_user.upper() == nova_palavra):
              resultado_chute = True
            else:
              resultado_chute = False
            break
        break
      else:
        print('Erro! Você não digitou uma das opções disponíveis!')
        print('Por favor, tente novamente.')
        print('-' * 30)
    else:
      # QUANDO ACABAR AS CHANCES DE ERRAR, O PRIMEIRO LAÇO WHILE PARA AQUI
      break

  print('-' * 30)
  if(num_max_erros_letras == 0):
    print('Suas tentativas acabaram!')
  elif((resultado_chute == True) or (palavra_completada == True)):
    print('Parabéns! Você acertou!')
  else:
    print('Você errou!')

  print(f'A palavra correta era: {nova_palavra}')
  print('FIM DE JOGO!')
  print('-' * 30)